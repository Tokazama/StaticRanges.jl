var documenterSearchIndex = {"docs":
[{"location":"abstractaxis/#AbstractAxis-1","page":"AbstractAxis","title":"AbstractAxis","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"Currently this functionality is exerimental. If the AbstractAxis interface proves useful it will likely be moved to a different package.","category":"page"},{"location":"abstractaxis/#Indexing-1","page":"AbstractAxis","title":"Indexing","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"The standard syntax for indexing doesn't change at all.","category":"page"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"julia> using StaticRanges\n\njulia> sa = SimpleAxis(1:10)\nSimpleAxis(1:10)\n\njulia> sa[2]\n2\n\njulia> sa[>(2)]\nSimpleAxis(3:10)\n\njulia> a = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\njulia> a[2]\n2\n\njulia> a[2:3]\nAxis(2:3 => 2:3)","category":"page"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"But now we can also use functions to index by the the keys of an AbstractAxis.","category":"page"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"julia> using StaticRanges\n\njulia> a = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> a[1]\n1\n\njulia> a[isequal(2.0)]\n1\n\njulia> a[>(2)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[>(2.0)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[and(>(2.0), <(8.0))]\nAxis(3.0:1.0:7.0 => 2:6)","category":"page"},{"location":"abstractaxis/#Benchmarks-1","page":"AbstractAxis","title":"Benchmarks","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"Indexing CartesianAxes is comparable to that of CartesianIndices","category":"page"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"julia> using StaticRanges, BenchmarkTools\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> @btime getindex(cartaxes, 2, 2)\n  20.848 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartinds, 2, 2)\n  22.317 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartaxes, ==(3.0), 2)\n  444.374 ns (7 allocations: 416 bytes)\nCartesianIndex(2, 2)\n","category":"page"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"Indexing LinearAxes is comparable to that of LinearIndices","category":"page"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"julia> using StaticRanges, BenchmarkTools\n\njulia> linaxes = LinearAxes((Axis(1.0:4.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> @btime getindex(linaxes, 2, 2)\n  18.275 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(lininds, 2, 2)\n  18.849 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(linaxes, ==(3.0), 2)\n  381.098 ns (6 allocations: 384 bytes)\n7","category":"page"},{"location":"abstractaxis/#Chaining-filters-1","page":"AbstractAxis","title":"Chaining filters","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.and\nStaticRanges.or","category":"page"},{"location":"abstractaxis/#StaticRanges.and","page":"AbstractAxis","title":"StaticRanges.and","text":"and(x, y)\n\nSynonymous with bitwise & operator but may be used to chain multiple Fix1 or Fix2 operations.\n\nExamples\n\njulia> using StaticRanges\n\njulia> and(<(5), true)(1)\ntrue\n\njulia> and(<(5), false)(1)\nfalse\n\njulia> and(and(<(5), >(1)), >(2))(3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.or","page":"AbstractAxis","title":"StaticRanges.or","text":"or(x, y)\n\nSynonymous with bitwise | operator but may be used to chain multiple Fix1 or Fix2 operations.\n\nExamples\n\njulia> using StaticRanges\n\njulia> or(<(5), true)(1)\ntrue\n\njulia> or(<(5), false)(1)\ntrue\n\njulia> or(or(<(5), >(1)), >(2))(3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#Reindexing-1","page":"AbstractAxis","title":"Reindexing","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.reindex\nStaticRanges.unsafe_reindex","category":"page"},{"location":"abstractaxis/#StaticRanges.reindex","page":"AbstractAxis","title":"StaticRanges.reindex","text":"reindex(a::AbstractAxis, inds::AbstractVector{Integer}) -> AbstractAxis\n\nReturns and index of the same type as a where the keys the new keys are constructed by indexing into the keys of a with inds and the values have the same starting value but a length matching inds.\n\nExamples\n\njulia> using StaticRanges\n\njulia> x, y, z = Axis(1:10, 2:11), Axis(1:10), SimpleAxis(1:10);\n\njulia>  reindex(x, collect(1:2:10))\nAxis([1, 3, 5, 7, 9] => 2:6)\n\njulia> reindex(y, collect(1:2:10))\nAxis([1, 3, 5, 7, 9] => Base.OneTo(5))\n\njulia> reindex(z, collect(1:2:10))\nSimpleAxis(1:5)\n\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.unsafe_reindex","page":"AbstractAxis","title":"StaticRanges.unsafe_reindex","text":"unsafe_reindex(a::AbstractAxis, inds::AbstractVector) -> AbstractAxis\n\nSimilar to reindex this function returns an index of the same type as a but doesn't check that inds is inbounds. New subtypes of AbstractAxis must implement a unique unsafe_reindex method.\n\nSee also: reindex\n\nExamples\n\njulia> using StaticRanges\n\njulia> StaticRanges.unsafe_reindex(SimpleAxis(OneToMRange(10)), 1:5)\nSimpleAxis(OneToMRange(5))\n\njulia> StaticRanges.unsafe_reindex(SimpleAxis(OneToSRange(10)), 1:5)\nSimpleAxis(OneToSRange(5))\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#Types-1","page":"AbstractAxis","title":"Types","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.AbstractAxis\nStaticRanges.Axis\nStaticRanges.SimpleAxis\nStaticRanges.CartesianAxes\nStaticRanges.LinearAxes","category":"page"},{"location":"abstractaxis/#StaticRanges.AbstractAxis","page":"AbstractAxis","title":"StaticRanges.AbstractAxis","text":"AbstractAxis\n\nAn AbstractVector subtype optimized for indexing.\n\n\n\n\n\n","category":"type"},{"location":"abstractaxis/#StaticRanges.Axis","page":"AbstractAxis","title":"StaticRanges.Axis","text":"Axis(k[, v=OneTo(length(k))])\n\nSubtypes of AbstractAxis that maps keys to values. The first argument specifies the keys and the second specifies the values. If only one argument is specified then the values span from 1 to the length of k.\n\nExamples\n\nThe value for all of these is the same.\n\njulia> using StaticRanges\n\njulia> x = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> y = Axis(2.0:11.0)  # when only one argument is specified assume it's the keys\nAxis(2.0:1.0:11.0 => Base.OneTo(10))\n\njulia> z = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\nStandard indexing returns the same values\n\njulia> x[2]\n2\n\njulia> x[2] == y[2] == z[2]\ntrue\n\njulia> x[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[1:2]\nAxis(1:2 => 1:2)\n\njulia> x[1:2] == y[1:2] == z[1:2]\ntrue\n\nFunctions that return true or false may be used to search the keys for their corresponding index. The following is equivalent to the previous example.\n\njulia> x[==(3.0)]\n2\n\njulia> x[==(3.0)] ==       # 3.0 is the 2nd key of x\n       y[isequal(3.0)] ==  # 3.0 is the 2nd key of y\n       z[==(2)]            # 2 is the 2nd key of z\ntrue\n\njulia> x[<(4.0)]  # all keys less than 4.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[<=(3.0)]  # all keys less than or equal to 3.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[<(3)]  # all keys less than or equal to 3 are 1:2 which correspond to values 1:2\nAxis(1:2 => 1:2)\n\njulia> x[<(4.0)] == y[<=(3.0)] == z[<(3)]\ntrue\n\nNotice that == returns a single value instead of a collection of all elements where the key was found to be true. This is because all keys must be unique so there can only ever be one element returned.\n\n\n\n\n\n","category":"type"},{"location":"abstractaxis/#StaticRanges.SimpleAxis","page":"AbstractAxis","title":"StaticRanges.SimpleAxis","text":"SimpleAxis(v)\n\nPovides an AbstractAxis interface for any AbstractUnitRange, v. v will be considered both the values and keys of the return instance. \n\nExamples\n\nA SimpleAxis is useful for giving a standard set of indices the ability to use the filtering syntax for indexing.\n\njulia> using StaticRanges\n\njulia> x = SimpleAxis(2:10)\nSimpleAxis(2:10)\n\njulia> x[2]\n3\n\njulia> x[==(2)]\n2\n\njulia> x[2] == x[==(3)]\ntrue\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\n\n\n\n\n","category":"type"},{"location":"abstractaxis/#StaticRanges.CartesianAxes","page":"AbstractAxis","title":"StaticRanges.CartesianAxes","text":"CartesianAxes\n\nExamples\n\njulia> using StaticRanges\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> cartaxes[2, 2]\n(2, 2)\n\njulia> cartinds[2, 2]\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"type"},{"location":"abstractaxis/#StaticRanges.LinearAxes","page":"AbstractAxis","title":"StaticRanges.LinearAxes","text":"LinearAxes\n\nExamples\n\njulia> using StaticRanges\n\njulia> linaxes = LinearAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> linaxes[2, 2]\n6\n\njulia> lininds[2, 2]\n6\n\n\n\n\n\n","category":"type"},{"location":"abstractaxis/#Interface-1","page":"AbstractAxis","title":"Interface","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.values_type\nStaticRanges.keys_type","category":"page"},{"location":"abstractaxis/#StaticRanges.values_type","page":"AbstractAxis","title":"StaticRanges.values_type","text":"values_type(::AbstractAxis)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.keys_type","page":"AbstractAxis","title":"StaticRanges.keys_type","text":"keys_type(::AbstractAxis)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#Swapping-Axes-1","page":"AbstractAxis","title":"Swapping Axes","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.drop_axes\nStaticRanges.permute_axes\nStaticRanges.reduce_axes\nStaticRanges.reduce_axis","category":"page"},{"location":"abstractaxis/#StaticRanges.drop_axes","page":"AbstractAxis","title":"StaticRanges.drop_axes","text":"drop_axes(x, dims)\n\nReturns all axes of x except for those identified by dims. Elements of dims must be unique integers or symbols corresponding to the dimensions or names of dimensions of x.\n\nExamples\n\njulia> using StaticRanges\n\njulia> axs = (Axis(1:5), Axis(1:10));\n\njulia> drop_axes(axs, 1)\n(Axis(1:10 => Base.OneTo(10)),)\n\njulia> drop_axes(axs, 2)\n(Axis(1:5 => Base.OneTo(5)),)\n\njulia> drop_axes(rand(2, 4), 2)\n(Base.OneTo(2),)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.permute_axes","page":"AbstractAxis","title":"StaticRanges.permute_axes","text":"permute_axes(x::AbstractArray, p::Tuple) = permute_axes(axes(x), p)\npermute_axes(x::NTuple{N}, p::NTuple{N}) -> NTuple{N}\n\nReturns axes of x in the order of p.\n\nExamples\n\njulia> using StaticRanges\n\njulia> permute_axes(rand(2, 4, 6), (1, 3, 2))\n(Base.OneTo(2), Base.OneTo(6), Base.OneTo(4))\n\njulia> permute_axes((Axis(1:2), Axis(1:4), Axis(1:6)), (1, 3, 2))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\npermute_axes(x::AbstractVector)\n\nReturns the permuted axes of x as axes of size 1 Ã— length(x)\n\nExamples\n\njulia> using StaticRanges\n\njulia> permute_axes(rand(4))\n(Base.OneTo(1), Base.OneTo(4))\n\njulia> permute_axes((Axis(1:4),))\n(Axis(1:1 => Base.OneTo(1)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\npermute_axes(m::AbstractMatrix) -> NTuple{2}\n\nPermute the axes of the matrix m, by flipping the elements across the diagonal of the matrix. Differs from LinearAlgebra's transpose in that the operation is not recursive.\n\nExamples\n\njulia> using StaticRanges\n\njulia> permute_axes(rand(4, 2))\n(Base.OneTo(2), Base.OneTo(4))\n\njulia> permute_axes((Axis(1:4), Axis(1:2)))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.reduce_axes","page":"AbstractAxis","title":"StaticRanges.reduce_axes","text":"reduce_axes(a, dims)\n\nReturns the appropriate axes for a measure that reduces dimensions along the dimensions dims.\n\nExample\n\njulia> using StaticRanges\n\njulia> reduce_axes(rand(2, 4), 2)\n(Base.OneTo(2), Base.OneTo(1))\n\njulia> reduce_axes(rand(2, 4), (1,2))\n(Base.OneTo(1), Base.OneTo(1))\n\njulia> reduce_axes(rand(2, 4), :)\n()\n\njulia> reduce_axes((Axis(1:4), Axis(1:4)), 2)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:1 => Base.OneTo(1)))\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.reduce_axis","page":"AbstractAxis","title":"StaticRanges.reduce_axis","text":"reduce_axis(a)\n\nReduces axis a to single value. Allows custom index types to have custom behavior throughout reduction methods (e.g., sum, prod, etc.)\n\nSee also: reduce_axes\n\nExample\n\njulia> using StaticRanges\n\njulia> reduce_axis(Axis(1:4))\nAxis(1:1 => Base.OneTo(1))\n\njulia> reduce_axis(1:4)\n1:1\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#Matrix-Multiplication-and-Axes-1","page":"AbstractAxis","title":"Matrix Multiplication and Axes","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.matmul_axes\nStaticRanges.inverse_axes\nStaticRanges.covcor_axes","category":"page"},{"location":"abstractaxis/#StaticRanges.matmul_axes","page":"AbstractAxis","title":"StaticRanges.matmul_axes","text":"matmul_axes(a, b) -> Tuple\n\nReturns the appropriate axes for the return of a * b where a and b are a vector or matrix.\n\nExamples\n\njulia> using StaticRanges\n\njulia> axs2, axs1 = (Axis(1:2), Axis(1:4)), (Axis(1:6),);\n\njulia> matmul_axes(axs2, axs2)\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\njulia> matmul_axes(axs1, axs2)\n(Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\njulia> matmul_axes(axs2, axs1)\n(Axis(1:2 => Base.OneTo(2)),)\n\njulia> matmul_axes(axs1, axs1)\n()\n\njulia> matmul_axes(rand(2, 4), rand(4, 2))\n(Base.OneTo(2), Base.OneTo(2))\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.inverse_axes","page":"AbstractAxis","title":"StaticRanges.inverse_axes","text":"inverse_axes(a::AbstractMatrix) = inverse_axes(axes(a))\ninverse_axes(a::Tuple{I1,I2}) -> Tuple{I2,I1}\n\nReturns the inverted axes of a, corresponding to the inv method from the  LinearAlgebra package in the standard library.\n\nExamples\n\njulia> using StaticRanges\n\njulia> inverse_axes(rand(2,4))\n(Base.OneTo(4), Base.OneTo(2))\n\njulia> inverse_axes((Axis(1:2), Axis(1:4)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:2 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.covcor_axes","page":"AbstractAxis","title":"StaticRanges.covcor_axes","text":"covcor_axes(x, dim) -> NTuple{2}\n\nReturns appropriate axes for a cov or var method on array x.\n\nExamples\n\njulia> using StaticRanges\n\njulia> covcor_axes(rand(2,4), 1)\n(Base.OneTo(4), Base.OneTo(4))\n\njulia> covcor_axes((Axis(1:4), Axis(1:6)), 2)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> covcor_axes((Axis(1:4), Axis(1:4)), 1)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#Appending-Axes-1","page":"AbstractAxis","title":"Appending Axes","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.append_axes\nStaticRanges.append_axes!\nStaticRanges.append_keys\nStaticRanges.append_values\nStaticRanges.append_axis\nStaticRanges.append_axis!","category":"page"},{"location":"abstractaxis/#StaticRanges.append_axes","page":"AbstractAxis","title":"StaticRanges.append_axes","text":"append_axes(x, y)\n\nReturns the axes for append(x, y).\n\njulia> using StaticRanges\n\njulia> append_axes(1:10, 1:10)\n(Base.OneTo(20),)\n\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.append_axes!","page":"AbstractAxis","title":"StaticRanges.append_axes!","text":"append_axes!(x, y)\n\nReturns the axes for append!(x, y).\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.append_keys","page":"AbstractAxis","title":"StaticRanges.append_keys","text":"append_keys(x, y)\n\nReturns the appropriate keys of and index within the operation append_axis(x, y)\n\nSee also: append_axis\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.append_values","page":"AbstractAxis","title":"StaticRanges.append_values","text":"append_values(x, y)\n\nReturns the appropriate values of and index within the operation append_axis(x, y)\n\nSee also: append_axis\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.append_axis","page":"AbstractAxis","title":"StaticRanges.append_axis","text":"append_axis(x, y)\n\nReturns the appended axes x and y. New subtypes of AbstractAxis must implement a unique append_axis method.\n\nExamples\n\njulia> using StaticRanges\n\njulia> append_axis(Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nAxis(UnitMRange(1:20) => UnitMRange(1:20))\n\njulia> append_axis(SimpleAxis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nSimpleAxis(UnitMRange(1:20))\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.append_axis!","page":"AbstractAxis","title":"StaticRanges.append_axis!","text":"append_axis!(x, y)\n\nReturns the appended axes x and y. New subtypes of AbstractAxis must implement a unique append_axis! method.\n\nExamples\n\njulia> using StaticRanges\n\njulia> x, y = Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10));\n\njulia> append_axis!(x, y);\n\njulia> length(x)\n20\n\njulia> append_axis!(y, x);\n\njulia> length(y)\n30\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#Concatenating-Axes-1","page":"AbstractAxis","title":"Concatenating Axes","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.hcat_axes\nStaticRanges.vcat_axes\nStaticRanges.cat_axis\nStaticRanges.cat_values\nStaticRanges.cat_keys","category":"page"},{"location":"abstractaxis/#StaticRanges.hcat_axes","page":"AbstractAxis","title":"StaticRanges.hcat_axes","text":"hcat_axes(x, y) -> Tuple\n\nReturns the appropriate axes for hcat(x, y).\n\nExamples\n\njulia> using StaticRanges\n\njulia> hcat_axes((Axis(1:4), Axis(1:2)), (Axis(1:4), Axis(1:2)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> a, b = [1; 2; 3; 4; 5], [6 7; 8 9; 10 11; 12 13; 14 15];\n\njulia> hcat_axes(a, b) == axes(hcat(a, b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.vcat_axes","page":"AbstractAxis","title":"StaticRanges.vcat_axes","text":"vcat_axes(x, y) -> Tuple\n\nReturns the appropriate axes for vcat(x, y).\n\nExamples\n\njulia> using StaticRanges\n\njulia> vcat_axes((Axis(1:2), Axis(1:4)), (Axis(1:2), Axis(1:4)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> a, b = [1 2 3 4 5], [6 7 8 9 10; 11 12 13 14 15];\n\njulia> vcat_axes(a, b) == axes(vcat(a, b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.cat_axis","page":"AbstractAxis","title":"StaticRanges.cat_axis","text":"cat_axis(x, y)\n\nReturns the concatenation of the axes x and y. New subtypes of AbstractAxis must implement a unique cat_axis method.\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.cat_values","page":"AbstractAxis","title":"StaticRanges.cat_values","text":"cat_values(x, y)\n\nReturns the appropriate values of the x and y index within the operation cat_axis(x, y)\n\nSee also: cat_axis\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.cat_keys","page":"AbstractAxis","title":"StaticRanges.cat_keys","text":"cat_keys(x, y)\n\nReturns the appropriate keys of the x and y index within the operation cat_axis(x, y)\n\nSee also: cat_axis\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#Resizing-Axes-1","page":"AbstractAxis","title":"Resizing Axes","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.resize_first\nStaticRanges.resize_first!\nStaticRanges.resize_last\nStaticRanges.resize_last!\n\nStaticRanges.grow_first\nStaticRanges.grow_first!\nStaticRanges.grow_last\nStaticRanges.grow_last!\n\nStaticRanges.shrink_first\nStaticRanges.shrink_first!\nStaticRanges.shrink_last\nStaticRanges.shrink_last!\n\nStaticRanges.next_type\nStaticRanges.prev_type","category":"page"},{"location":"abstractaxis/#StaticRanges.resize_first","page":"AbstractAxis","title":"StaticRanges.resize_first","text":"resize_first(x, n::Integer)\n\nReturns a collection similar to x that grows or shrinks from the first index to be of size n.\n\nExamples\n\njulia> using StaticRanges\n\njulia> x = collect(1:5);\n\njulia> resize_first(x, 2)\n2-element Array{Int64,1}:\n 4\n 5\n\njulia> resize_first(x, 7)\n7-element Array{Int64,1}:\n -1\n  0\n  1\n  2\n  3\n  4\n  5\n\njulia> resize_first(x, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.resize_first!","page":"AbstractAxis","title":"StaticRanges.resize_first!","text":"resize_first!(x, n::Integer)\n\nReturns the collection x after growing or shrinking the first index to be of size n.\n\nExamples\n\njulia> using StaticRanges\n\njulia> x = collect(1:5);\n\njulia> resize_first!(x, 2);\n\njulia> x\n2-element Array{Int64,1}:\n 4\n 5\n\njulia> resize_first!(x, 6);\n\njulia> x\n6-element Array{Int64,1}:\n 0\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.resize_last","page":"AbstractAxis","title":"StaticRanges.resize_last","text":"resize_last(x, n::Integer)\n\nReturns a collection similar to x that grows or shrinks from the last index to be of size n.\n\nExamples\n\njulia> using StaticRanges\n\njulia> x = collect(1:5);\n\njulia> resize_last(x, 2)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> resize_last(x, 7)\n7-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n\njulia>  resize_last(x, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.resize_last!","page":"AbstractAxis","title":"StaticRanges.resize_last!","text":"resize_last!(x, n::Integer)\n\nReturns the collection x after growing or shrinking the last index to be of size n.\n\nExamples\n\njulia> using StaticRanges\n\njulia> x = collect(1:5);\n\njulia> resize_last!(x, 2);\n\njulia> x\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> resize_last!(x, 5);\n\njulia> x\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.grow_first","page":"AbstractAxis","title":"StaticRanges.grow_first","text":"grow_first(x, n)\n\nReturns a collection similar to x that grows by n elements from the first index.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_first(mr, 2)\nUnitMRange(-1:10)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.grow_first!","page":"AbstractAxis","title":"StaticRanges.grow_first!","text":"grow_first!(x, n)\n\nReturns the collection x after growing from the first index by n elements.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_first!(mr, 2);\n\njulia> mr\nUnitMRange(-1:10)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.grow_last","page":"AbstractAxis","title":"StaticRanges.grow_last","text":"grow_last(x, n)\n\nReturns a collection similar to x that grows by n elements from the last index.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_last(mr, 2)\nUnitMRange(1:12)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.grow_last!","page":"AbstractAxis","title":"StaticRanges.grow_last!","text":"grow_last!(x, n)\n\nReturns the collection x after growing from the last index by n elements.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_last!(mr, 2);\n\njulia> mr\nUnitMRange(1:12)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.shrink_first","page":"AbstractAxis","title":"StaticRanges.shrink_first","text":"shrink_first(x, n)\n\nReturns a collection similar to x that shrinks by n elements from the first index.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> shrink_first(mr, 2)\nUnitMRange(3:10)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.shrink_first!","page":"AbstractAxis","title":"StaticRanges.shrink_first!","text":"shrink_first!(x, n)\n\nReturns the collection x after shrinking from the first index by n elements.\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.shrink_last","page":"AbstractAxis","title":"StaticRanges.shrink_last","text":"shrink_last(x, n)\n\nReturns a collection similar to x that shrinks by n elements from the last index.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> shrink_first!(mr, 2);\n\njulia> mr\nUnitMRange(3:10)\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.shrink_last!","page":"AbstractAxis","title":"StaticRanges.shrink_last!","text":"shrink_last!(x, n)\n\nReturns the collection x after shrinking from the last index by n elements.\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.next_type","page":"AbstractAxis","title":"StaticRanges.next_type","text":"next_type(x::T)\n\nReturns the immediately greater value of type T.\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.prev_type","page":"AbstractAxis","title":"StaticRanges.prev_type","text":"prev_type(x::T)\n\nReturns the immediately lesser value of type T.\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#Combine-Indices-1","page":"AbstractAxis","title":"Combine Indices","text":"","category":"section"},{"location":"abstractaxis/#","page":"AbstractAxis","title":"AbstractAxis","text":"StaticRanges.combine_indices\nStaticRanges.combine_index\nStaticRanges.combine_values\nStaticRanges.combine_keys","category":"page"},{"location":"abstractaxis/#StaticRanges.combine_indices","page":"AbstractAxis","title":"StaticRanges.combine_indices","text":"combine_indices(x, y)\n\nReturns the combined axes of x and y for broadcasting operations.\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.combine_index","page":"AbstractAxis","title":"StaticRanges.combine_index","text":"combine_index(x, y)\n\nReturns the combination of x and y, creating a new index. New subtypes of AbstractAxis should implement a combine_index method.\n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.combine_values","page":"AbstractAxis","title":"StaticRanges.combine_values","text":"combine_values(x, y)\n\nReturns the combination of the values of x and y, creating a new index. New subtypes of AbstractAxis may implement a unique combine_values method if  needed. Default behavior is to use the return of promote_rule(x, y) for the type of the combined values. \n\n\n\n\n\n","category":"function"},{"location":"abstractaxis/#StaticRanges.combine_keys","page":"AbstractAxis","title":"StaticRanges.combine_keys","text":"combine_keys(x::AbstractAxis, y::AbstractAxis)\n\nReturns the combination of the keys of x and y, creating a new index. New subtypes of AbstractAxis may implement a unique combine_keys method if  needed. Default behavior is to use the return of promote_rule(x, y) for the type of the combined keys. \n\n\n\n\n\n","category":"function"},{"location":"order_functions/#Order-Functions-1","page":"Order Functions","title":"Order Functions","text":"","category":"section"},{"location":"order_functions/#Optimized-for-Order-1","page":"Order Functions","title":"Optimized for Order","text":"","category":"section"},{"location":"order_functions/#","page":"Order Functions","title":"Order Functions","text":"StaticRanges.ordmax\nStaticRanges.ordmin\nStaticRanges.find_max\nStaticRanges.find_min\nStaticRanges.is_within\nStaticRanges.gtmax\nStaticRanges.ltmax\nStaticRanges.eqmax\nStaticRanges.gtmin\nStaticRanges.ltmin\nStaticRanges.eqmin\nStaticRanges.group_max\nStaticRanges.group_min\nStaticRanges.cmpmax\nStaticRanges.cmpmin\nStaticRanges.min_of_group_max\nStaticRanges.max_of_group_min","category":"page"},{"location":"order_functions/#StaticRanges.ordmax","page":"Order Functions","title":"StaticRanges.ordmax","text":"ordmax(x) = ordmax(x, order(x))\nordmax(x::T, ::Ordering) -> T\n\nFinds the maximum of x using information about its ordering.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.ordmin","page":"Order Functions","title":"StaticRanges.ordmin","text":"ordmin(x) = ordmin(x, order(x))\nordmin(x::T, ::Ordering) -> T\n\nFinds the minimum of x using information about its ordering.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.find_max","page":"Order Functions","title":"StaticRanges.find_max","text":"find_max(x)\n\nReturns the index of the maximum value for x. Differes from findmax by accounting for any sorting.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.find_min","page":"Order Functions","title":"StaticRanges.find_min","text":"find_min(x)\n\nReturns the index of the minimum value for x. Differes from findmin by accounting for any sorting.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.is_within","page":"Order Functions","title":"StaticRanges.is_within","text":"is_within(x, y) -> Bool\n\nReturns true if all of x is found within y.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.gtmax","page":"Order Functions","title":"StaticRanges.gtmax","text":"gtmax(x, y) -> Bool\n\nReturns true if the maximum of x is greater than that of y.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.ltmax","page":"Order Functions","title":"StaticRanges.ltmax","text":"ltmax(x, y) -> Bool\n\nReturns true if the maximum of x is less than that of y.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.eqmax","page":"Order Functions","title":"StaticRanges.eqmax","text":"eqmax(x, y) -> Bool\n\nReturns true if the maximum of x and y are equal.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.gtmin","page":"Order Functions","title":"StaticRanges.gtmin","text":"gtmin(x, y) -> Bool\n\nReturns true if the minimum of x is greater than that of y.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.ltmin","page":"Order Functions","title":"StaticRanges.ltmin","text":"ltmin(x, y) -> Bool\n\nReturns true if the minimum of x is less than that of y.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.eqmin","page":"Order Functions","title":"StaticRanges.eqmin","text":"eqmin(x, y) -> Bool\n\nReturns true if the minimum of x and y are equal.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.group_max","page":"Order Functions","title":"StaticRanges.group_max","text":"group_max(x, y[, z...])\n\nReturns the maximum value of all collctions.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.group_min","page":"Order Functions","title":"StaticRanges.group_min","text":"group_min(x, y[, z...])\n\nReturns the minimum value of all collctions.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.cmpmax","page":"Order Functions","title":"StaticRanges.cmpmax","text":"cmpmax(x, y)\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.cmpmin","page":"Order Functions","title":"StaticRanges.cmpmin","text":"cmpmin(x, y)\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.min_of_group_max","page":"Order Functions","title":"StaticRanges.min_of_group_max","text":"min_of_group_max(x, y)\n\nReturns the minimum of maximum of x and y. Functionally equivalent to min(maximum(x), maximum(y)) but uses trait information about ordering for improved performance.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.max_of_group_min","page":"Order Functions","title":"StaticRanges.max_of_group_min","text":"max_of_group_min(x, y)\n\nReturns the maximum of minimum of x and y. Functionally equivalent to max(minimum(x), minimum(y)) but uses trait information about ordering for improved performance.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#Search-and-Sort-1","page":"Order Functions","title":"Search and Sort","text":"","category":"section"},{"location":"order_functions/#Order-traits-1","page":"Order Functions","title":"Order traits","text":"","category":"section"},{"location":"order_functions/#","page":"Order Functions","title":"Order Functions","text":"Internally it provides an intermediate structure for chaining functions an arbitrary number of functions.","category":"page"},{"location":"order_functions/#","page":"Order Functions","title":"Order Functions","text":"julia> fxn1 = <(4) | >(8)\n(::StaticRanges.ChainedFix{typeof(|),Base.Fix2{typeof(<),Int64},Base.Fix2{typeof(>),Int64}}) (generic function with 3 methods)\n\njulia> fxn2 = <(4) | >(8) & iseven\n(::StaticRanges.ChainedFix{typeof(|),Base.Fix2{typeof(<),Int64},StaticRanges.ChainedFix{typeof(&),Base.Fix2{typeof(>),Int64},typeof(iseven)}}) (generic function with 3 methods)\n\njulia> fxn1(10)\ntrue\n\njulia> fxn1(11)\ntrue\n\njulia> fxn2(10)\ntrue\n\njulia> fxn2(11)\nfalse","category":"page"},{"location":"order_functions/#","page":"Order Functions","title":"Order Functions","text":"This becomes particularly useful when trying to preserve a range in a type stable manner. Without knowing the specific functions that compose the conditional operator in findall at compile time it's impossible to determine whether the output should be a continuous range or discrete vector.","category":"page"},{"location":"order_functions/#","page":"Order Functions","title":"Order Functions","text":"julia> findall(i -> >(4)(i) & <(8)(i), fr)\n2-element Array{Int64,1}:\n 3\n 4\n\njulia> find_all(>(4) & <(8), fr)\n3:4","category":"page"},{"location":"order_functions/#","page":"Order Functions","title":"Order Functions","text":"StaticRanges.find_first\nStaticRanges.find_last\nStaticRanges.merge_sort\nStaticRanges.vcat_sort","category":"page"},{"location":"order_functions/#StaticRanges.find_first","page":"Order Functions","title":"StaticRanges.find_first","text":"find_first(predicate::Function, A)\n\nReturn the index or key of the first element of A for which predicate returns true. Return nothing if there is no such element.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> using StaticRanges\n\njulia> A = [1, 4, 2, 2];\n\njulia> find_first(iseven, A)\n2\n\njulia> find_first(x -> x>10, A) # returns nothing, but not printed in the REPL\n\njulia> find_first(isequal(4), A)\n2\n\njulia> find_first(iseven, [1 4; 2 2])\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.find_last","page":"Order Functions","title":"StaticRanges.find_last","text":"find_last(predicate::Function, A)\n\nReturn the index or key of the last element of A for which predicate returns true. Return nothing if there is no such element.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> using StaticRanges\n\njulia> find_last(iseven, [1, 4, 2, 2])\n4\n\njulia> find_last(x -> x>10, [1, 4, 2, 2]) # returns nothing, but not printed in the REPL\n\njulia> find_last(isequal(4), [1, 4, 2, 2])\n2\n\njulia> find_last(iseven, [1 4; 2 2])\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.merge_sort","page":"Order Functions","title":"StaticRanges.merge_sort","text":"merge_sort(x, y)\n\nMerge's and sorts collections x, and y.\n\n\n\n\n\n","category":"function"},{"location":"order_functions/#StaticRanges.vcat_sort","page":"Order Functions","title":"StaticRanges.vcat_sort","text":"vcat_sort(x, y)\n\nReturns a sorted concatenation of x and y.\n\n\n\n\n\n","category":"function"},{"location":"traits/#Traits-1","page":"Traits","title":"Traits","text":"","category":"section"},{"location":"traits/#Comparing-Static,-Mutable,-and-Immutable-Types-1","page":"Traits","title":"Comparing Static, Mutable, and Immutable Types","text":"","category":"section"},{"location":"traits/#","page":"Traits","title":"Traits","text":"The difference between each type of range is conceptualized as \"static\", \"fixed\", or \"dynamic\".","category":"page"},{"location":"traits/#","page":"Traits","title":"Traits","text":"StaticRanges.is_dynamic\nStaticRanges.is_static\nStaticRanges.is_fixed\n\nStaticRanges.as_dynamic\nStaticRanges.as_static\nStaticRanges.as_fixed","category":"page"},{"location":"traits/#StaticRanges.is_dynamic","page":"Traits","title":"StaticRanges.is_dynamic","text":"is_dynamic(x) -> Bool\n\nReturns true if the size of x is dynamic/can change.\n\nExamples\n\njulia> using StaticRanges\n\njulia> sr = UnitSRange(1, 10)\nUnitSRange(1:10)\n\njulia> mr = StepMRange(1, 2, 20)\nStepMRange(1:2:19)\n\njulia> fr = StepRange(1, 2, 20)\n1:2:19\n\njulia> is_dynamic(sr)\nfalse\n\njulia> is_dynamic(fr)\nfalse\n\njulia> is_dynamic(mr)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.is_static","page":"Traits","title":"StaticRanges.is_static","text":"is_static(x) -> Bool\n\nReturns true if x is static.\n\nExamples\n\njulia> using StaticRanges\n\njulia> sr = UnitSRange(1, 10)\nUnitSRange(1:10)\n\njulia> mr = StepMRange(1, 2, 20)\nStepMRange(1:2:19)\n\njulia> fr = StepRange(1, 2, 20)\n1:2:19\n\njulia> is_static(sr)\ntrue\n\njulia> is_static(mr)\nfalse\n\njulia> is_static(fr)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.is_fixed","page":"Traits","title":"StaticRanges.is_fixed","text":"is_fixed(x) -> Bool\n\nReturns true if the size of x is fixed.\n\nExamples\n\njulia> using StaticRanges\n\njulia> sr = UnitSRange(1, 10)\nUnitSRange(1:10)\n\njulia> mr = StepMRange(1, 2, 20)\nStepMRange(1:2:19)\n\njulia> fr = StepRange(1, 2, 20)\n1:2:19\n\njulia> is_fixed(sr)\nfalse\n\njulia> is_fixed(fr)\ntrue\n\njulia> is_fixed(mr)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.as_dynamic","page":"Traits","title":"StaticRanges.as_dynamic","text":"as_dynamic(x)\n\nIf x is mutable then returns x, otherwise returns a comparable but mutable type to x.\n\nExamples\n\njulia> using StaticRanges\n\njulia> as_dynamic(Base.OneTo(10))\nOneToMRange(10)\n\njulia> as_dynamic(UnitRange(1, 10))\nUnitMRange(1:10)\n\njulia> as_dynamic(StepRange(1, 2, 20))\nStepMRange(1:2:19)\n\njulia> as_dynamic(range(1.0, step=2.0, stop=20.0))\nStepMRangeLen(1.0:2.0:19.0)\n\njulia> as_dynamic(LinRange(1, 20, 10))\nLinMRange(1.0, stop=20.0, length=10)\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.as_static","page":"Traits","title":"StaticRanges.as_static","text":"as_static(x)\n\nIf x is static then returns x, otherwise returns a comparable but static size type to x.\n\nExamples\n\njulia> using StaticRanges\n\njulia> as_static(Base.OneTo(10))\nOneToSRange(10)\n\njulia> as_static(UnitRange(1, 10))\nUnitSRange(1:10)\n\njulia> as_static(StepRange(1, 2, 20))\nStepSRange(1:2:19)\n\njulia> as_static(range(1.0, step=2.0, stop=20.0))\nStepSRangeLen(1.0:2.0:19.0)\n\njulia> as_static(LinRange(1, 20, 10))\nLinSRange(1.0, stop=20.0, length=10)\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.as_fixed","page":"Traits","title":"StaticRanges.as_fixed","text":"as_fixed(x)\n\nIf x is immutable then returns x, otherwise returns a comparable but fixed size type to x.\n\nExamples\n\njulia> using StaticRanges\n\njulia> as_fixed(OneToMRange(10))\nBase.OneTo(10)\n\njulia> as_fixed(UnitMRange(1, 10))\n1:10\n\njulia> as_fixed(StepMRange(1, 2, 20))\n1:2:19\n\njulia> as_fixed(mrange(1.0, step=2.0, stop=20.0))\n1.0:2.0:19.0\n\njulia> as_fixed(LinMRange(1, 20, 10))\n10-element LinRange{Float64}:\n 1.0,3.11111,5.22222,7.33333,9.44444,11.5556,13.6667,15.7778,17.8889,20.0\n\n\n\n\n\n","category":"function"},{"location":"traits/#Order-traits-1","page":"Traits","title":"Order traits","text":"","category":"section"},{"location":"traits/#","page":"Traits","title":"Traits","text":"The following traits are used to conveniently characterize the order of ranges.","category":"page"},{"location":"traits/#","page":"Traits","title":"Traits","text":"StaticRanges.is_forward\nStaticRanges.is_reverse\nStaticRanges.order\nStaticRanges.is_ordered\nStaticRanges.is_before\nStaticRanges.is_after\nStaticRanges.is_contiguous","category":"page"},{"location":"traits/#StaticRanges.is_forward","page":"Traits","title":"StaticRanges.is_forward","text":"is_forward(x) -> Bool\n\nReturns true if x is sorted forward.\n\nExamples\n\njulia> using StaticRanges\n\njulia> fr = 1:2:10\n1:2:9\n\njulia> rr = 10:-2:1\n10:-2:2\n\njulia> is_forward(fr)\ntrue\n\njulia> is_forward(rr)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.is_reverse","page":"Traits","title":"StaticRanges.is_reverse","text":"is_reverse(x) -> Bool\n\nReturns true if x is sorted in reverse.\n\nExamples\n\njulia> using StaticRanges\n\njulia> fr = 1:2:10\n1:2:9\n\njulia> rr = 10:-2:1\n10:-2:2\n\njulia> is_reverse(fr)\nfalse\n\njulia> is_reverse(rr)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.order","page":"Traits","title":"StaticRanges.order","text":"order(x) -> Ordering\n\nReturns the ordering of x.\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.is_ordered","page":"Traits","title":"StaticRanges.is_ordered","text":"is_ordered(x) -> Bool\n\nReturns true if x is ordered. is_ordered should return the same value that issorted would on x except it doesn't specify how it's sorted (e.g., forward, reverse, etc).\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.is_before","page":"Traits","title":"StaticRanges.is_before","text":"is_before(x::T, y::T, collection::AbstractVector{T}) -> Bool\n\nReturns true if x is before y in collection.\n\n\n\n\n\nis_before(x::AbstractVector{T}, y::AbstractVector{T}) -> is_before(order(x), order(y), x, y)\nis_before(::Ordering, ::Ordering, x, y) -> Bool\n\nReturns true if all elements in x are before all elements in y. Functionally equivalent to all(x .< y).\n\nExamples\n\njulia> using StaticRanges\n\njulia> r1 = 1:5\n1:5\n\njulia> r2 = 6:10\n6:10\n\njulia> is_before(r2, r1)\nfalse\n\njulia> is_before(r1, r2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.is_after","page":"Traits","title":"StaticRanges.is_after","text":"is_after(x::T, y::T, collection::AbstractVector{T}) -> Bool\n\nReturns true if x is after y in collection.\n\n\n\n\n\nis_after(x::AbstractVector{T}, y::AbstractVector{T}) -> is_after(order(x), order(y), x, y)\nis_after(::Ordering, ::Ordering, x, y) -> Bool\n\nReturns true if all elements in x are after all elements in y. Functionally equivalent to all(x .> y).\n\nExamples\n\njulia> using StaticRanges\n\njulia> r1 = 1:5\n1:5\n\njulia> r2 = 6:10\n6:10\n\njulia> is_after(r2, r1)\ntrue\n\njulia> is_after(r1, r2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"traits/#StaticRanges.is_contiguous","page":"Traits","title":"StaticRanges.is_contiguous","text":"is_contiguous(x, y) = is_contiguous(order(x), order(y), x, y)\nis_contiguous(::Ordering, ::Ordering, x, y) -> Bool\n\nReturns true if one of the ends of x may be extended by a single overlapping end of y.\n\nExample\n\njulia> using StaticRanges\n\njulia> is_contiguous(1:3, 3:4) == true\n\njulia> is_contiguous(3:-1:1, 3:4) == true\n\njulia> is_contiguous(3:-1:1, 4:-1:3) == true\n\njulia> is_contiguous(1:3, 4:-1:3) == true\n\njulia> is_contiguous(1:3, 2:4) == false\n\n\n\n\n\n","category":"function"},{"location":"find/#\"Find\"-Functions-1","page":"\"Find\" Functions","title":"\"Find\" Functions","text":"","category":"section"},{"location":"find/#","page":"\"Find\" Functions","title":"\"Find\" Functions","text":"These are further used to make quick simple comparisons between objects.","category":"page"},{"location":"find/#","page":"\"Find\" Functions","title":"\"Find\" Functions","text":"There are some small improvements to the family of \"find and filter\" methods available in base Julia. In Order to avoid type piracy but generalize the benefits to all types of ranges, some minor syntactic differences are used here.","category":"page"},{"location":"find/#","page":"\"Find\" Functions","title":"\"Find\" Functions","text":"Starting with findall, there's a difference in the type that is returned.","category":"page"},{"location":"find/#","page":"\"Find\" Functions","title":"\"Find\" Functions","text":"julia> mr = StepMRange(1, 2, 19)\nStepMRange(1:2:19)\n\njulia> @btime findall(<(5), $fr)\n  142.072 ns (3 allocations: 208 bytes)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> @btime find_all(<(5), $fr)\n  0.027 ns (0 allocations: 0 bytes)\n1:2","category":"page"},{"location":"find/#","page":"\"Find\" Functions","title":"\"Find\" Functions","text":"julia> r = 1:10\n1:10\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> findall(or(<(4), >(12)), mr)\n7-element Array{Int64,1}:\n  1\n  2\n  3\n  7\n  8\n  9\n 10\n\njulia> find_all(or(<(4), >(6)), r)\n7-element GapRange{Int64,UnitRange{Int64},UnitRange{Int64}}:\n  1\n  2\n  3\n  7\n  8\n  9\n 10\n\njulia> @btime filter(or(<(4), >(6)), $r)\n  124.496 ns (3 allocations: 320 bytes)\n7-element Array{Int64,1}:\n  1\n  2\n  3\n  7\n  8\n  9\n 10\n\njulia> @btime filter(or(<(4), >(6)), $mr)\n  72.911 ns (3 allocations: 208 bytes)\n7-element Array{Int64,1}:\n  1\n  2\n  3\n  7\n  8\n  9\n 10\n","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"StaticRanges was originally a small set of functions inspired by StaticArrays. It eventually evolved into a project the aimed to improve the performance and flexibility of range related methods. It's objectives are:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Easy/intuitive composition of mutable and static ranges.\nOptimized methods involving ranges: \"find\" methods are currently the focus and optimizations currently exist for findall, findfirst, findlast, filter, and count using the <, <=, >, >=, ==, and != operators.","category":"page"},{"location":"range_types/#Range-Types-1","page":"Range Types","title":"Range Types","text":"","category":"section"},{"location":"range_types/#Static-Ranges-1","page":"Range Types","title":"Static Ranges","text":"","category":"section"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"StaticRanges.OneToSRange\nStaticRanges.UnitSRange\nStaticRanges.LinSRange\nStaticRanges.StepSRange\nStaticRanges.StepSRangeLen","category":"page"},{"location":"range_types/#StaticRanges.OneToSRange","page":"Range Types","title":"StaticRanges.OneToSRange","text":"OneToSRange\n\nA static range that parallels OneTo in behavior.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.UnitSRange","page":"Range Types","title":"StaticRanges.UnitSRange","text":"UnitSRange\n\nA static range parameterized by a start and stop of type T, filled with elements spaced by 1 from start until stop is exceeded. The syntax a:b with a and b both Integers creates a UnitRange.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.LinSRange","page":"Range Types","title":"StaticRanges.LinSRange","text":"LinSRange\n\nA static range with len linearly spaced elements between its start and stop. The size of the spacing is controlled by len, which must be an Int.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.StepSRange","page":"Range Types","title":"StaticRanges.StepSRange","text":"StepSRange\n\nA static range with elements of type T with spacing of type S. The step between each element is constant, and the range is defined in terms of a start and stop of type T and a step of type S. Neither T nor S should be floating point types.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.StepSRangeLen","page":"Range Types","title":"StaticRanges.StepSRangeLen","text":"StepSRangeLen\n\nA static range r where r[i] produces values of type T (in the second form, T is deduced automatically), parameterized by a reference value, a step, and the length. By default ref is the starting value r[1], but alternatively you can supply it as the value of r[offset] for some other index 1 <= offset <= len. In conjunction with TwicePrecision this can be used to implement ranges that are free of roundoff error.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#Mutable-Ranges-1","page":"Range Types","title":"Mutable Ranges","text":"","category":"section"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"StaticRanges.OneToMRange\nStaticRanges.UnitMRange\nStaticRanges.LinMRange\nStaticRanges.StepMRange\nStaticRanges.StepMRangeLen","category":"page"},{"location":"range_types/#StaticRanges.OneToMRange","page":"Range Types","title":"StaticRanges.OneToMRange","text":"OneToMRange\n\nA mutable range that parallels OneTo in behavior.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.UnitMRange","page":"Range Types","title":"StaticRanges.UnitMRange","text":"UnitMRange\n\nA mutable range parameterized by a start and stop of type T, filled with elements spaced by 1 from start until stop is exceeded. The syntax a:b with a and b both Integers creates a UnitRange.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.LinMRange","page":"Range Types","title":"StaticRanges.LinMRange","text":"LinMRange\n\nA mutable range with len linearly spaced elements between its start and stop. The size of the spacing is controlled by len, which must be an Int.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.StepMRange","page":"Range Types","title":"StaticRanges.StepMRange","text":"StepMRange\n\nA mutable range with elements of type T with spacing of type S. The step between each element is constant, and the range is defined in terms of a start and stop of type T and a step of type S. Neither T nor S should be floating point types.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.StepMRangeLen","page":"Range Types","title":"StaticRanges.StepMRangeLen","text":"StepMRangeLen\n\nA mutable range r where r[i] produces values of type T (in the second form, T is deduced automatically), parameterized by a reference value, a step, and the length. By default ref is the starting value r[1], but alternatively you can supply it as the value of r[offset] for some other index 1 <= offset <= len. In conjunction with TwicePrecision this can be used to implement ranges that are free of roundoff error.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#Abstract-Ranges-1","page":"Range Types","title":"Abstract Ranges","text":"","category":"section"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"StaticRanges.OneToRange\nStaticRanges.AbstractLinRange\nStaticRanges.AbstractStepRangeLen\nStaticRanges.AbstractStepRange","category":"page"},{"location":"range_types/#StaticRanges.OneToRange","page":"Range Types","title":"StaticRanges.OneToRange","text":"OneToRange\n\nSupertype for OneToSRange and OneToMRange. It's subtypes should behave identically to Base.OneTo.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.AbstractLinRange","page":"Range Types","title":"StaticRanges.AbstractLinRange","text":"AbstractLinRange\n\nSupertype for mutable or static ranges with len linearly spaced elements between its start and stop.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.AbstractStepRangeLen","page":"Range Types","title":"StaticRanges.AbstractStepRangeLen","text":"AbstractStepRangeLen\n\nSupertype for StepSRangeLen and StepMRangeLen. It's subtypes should behave identically to StepRangeLen.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#StaticRanges.AbstractStepRange","page":"Range Types","title":"StaticRanges.AbstractStepRange","text":"AbstractStepRange\n\nSupertype for StepSRange and StepMRange. It's subtypes should behave identically to StepRange.\n\n\n\n\n\n","category":"type"},{"location":"range_types/#Special-Ranges-1","page":"Range Types","title":"Special Ranges","text":"","category":"section"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"StaticRanges.GapRange","category":"page"},{"location":"range_types/#StaticRanges.GapRange","page":"Range Types","title":"StaticRanges.GapRange","text":"GapRange{T,F,L}\n\nRepresents a range that is broken up by gaps making it noncontinuous. This allows more compact storage of numbers where the majority are known to be continuous.\n\nExamples\n\njulia> using StaticRanges\n\njulia> findall(and(>(4), <(10)), 1:10)\n5-element Array{Int64,1}:\n 5\n 6\n 7\n 8\n 9\n\njulia> find_all(or(<(4), >(6)), 1:10)\n7-element GapRange{Int64,UnitRange{Int64},UnitRange{Int64}}:\n  1\n  2\n  3\n  7\n  8\n  9\n 10\n\n\n\n\n\n","category":"type"},{"location":"range_types/#Manipulating-Ranges-1","page":"Range Types","title":"Manipulating Ranges","text":"","category":"section"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"There are options for in place mutations and corresponding non mutationg operations. These allow safe mutation of ranges by avoiding states that are typically prohibited at time of construction. For example, OneToMRange cannot have a negative value for it's stop field. These methods are also called whenever setproperty! is used.","category":"page"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"StaticRanges.can_set_first\nStaticRanges.set_first!\nStaticRanges.set_first","category":"page"},{"location":"range_types/#StaticRanges.can_set_first","page":"Range Types","title":"StaticRanges.can_set_first","text":"can_set_first(x) -> Bool\n\nReturns true if the first element of x can be set. If x is a range then changing the first element will also change the length of x.\n\n\n\n\n\n","category":"function"},{"location":"range_types/#StaticRanges.set_first!","page":"Range Types","title":"StaticRanges.set_first!","text":"set_first!(x, val)\n\nSet the first element of x to val.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10);\n\njulia> set_first!(mr, 2);\n\njulia> first(mr)\n2\n\n\n\n\n\n","category":"function"},{"location":"range_types/#StaticRanges.set_first","page":"Range Types","title":"StaticRanges.set_first","text":"set_first(x, val)\n\nReturns similar type as x with first value set to val.\n\nExamples\n\njulia> using StaticRanges\n\njulia> r = set_first(1:10, 2)\n2:10\n\n\n\n\n\n","category":"function"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"StaticRanges.can_set_step\nStaticRanges.set_step!\nStaticRanges.set_step","category":"page"},{"location":"range_types/#StaticRanges.can_set_step","page":"Range Types","title":"StaticRanges.can_set_step","text":"can_set_step(x) -> Bool\n\nReturns true if type of x has step field that can be set.\n\n\n\n\n\n","category":"function"},{"location":"range_types/#StaticRanges.set_step!","page":"Range Types","title":"StaticRanges.set_step!","text":"set_step!(x, st)\n\nSets the step of x to val.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = StepMRange(1, 1, 10);\n\njulia> set_step!(mr, 2);\n\njulia> step(mr)\n2\n\n\n\n\n\n","category":"function"},{"location":"range_types/#StaticRanges.set_step","page":"Range Types","title":"StaticRanges.set_step","text":"set_step(x, st)\n\nSets the step of x to val.\n\nExamples\n\njulia> using StaticRanges\n\njulia> set_step(1:1:10, 2)\n1:2:9\n\n\n\n\n\n","category":"function"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"StaticRanges.can_set_last\nStaticRanges.set_last!\nStaticRanges.set_last","category":"page"},{"location":"range_types/#StaticRanges.can_set_last","page":"Range Types","title":"StaticRanges.can_set_last","text":"can_set_last(x) -> Bool\n\nReturns true if the last element of x can be set. If x is a range then changing the first element will also change the length of x.\n\n\n\n\n\n","category":"function"},{"location":"range_types/#StaticRanges.set_last!","page":"Range Types","title":"StaticRanges.set_last!","text":"set_last!(x, val)\n\nSet the last element of x to val.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10);\n\njulia> set_last!(r, 5);\n\njulia> last(mr)\n5\n\n\n\n\n\n","category":"function"},{"location":"range_types/#StaticRanges.set_last","page":"Range Types","title":"StaticRanges.set_last","text":"set_last(x, val)\n\nReturns a similar type as x with its last value equal to val.\n\nExamplse\n\njulia> using StaticRanges\n\njulia> set_last(1:10, 5)\n1:5\n\n\n\n\n\n","category":"function"},{"location":"range_types/#","page":"Range Types","title":"Range Types","text":"StaticRanges.can_set_length\nStaticRanges.set_length!\nStaticRanges.set_length","category":"page"},{"location":"range_types/#StaticRanges.can_set_length","page":"Range Types","title":"StaticRanges.can_set_length","text":"can_set_length(x) -> Bool\n\nReturns true if type of x can have its length set independent of changing its first or last position.\n\n\n\n\n\n","category":"function"},{"location":"range_types/#StaticRanges.set_length!","page":"Range Types","title":"StaticRanges.set_length!","text":"set_length!(x, len)\n\nReturns a similar type as x with a length equal to len.\n\nExamples\n\njulia> using StaticRanges\n\njulia> mr = UnitMRange(1, 10);\n\njulia> set_length!(mr, 20);\n\njulia> length(mr)\n20\n\n\n\n\n\n","category":"function"},{"location":"range_types/#StaticRanges.set_length","page":"Range Types","title":"StaticRanges.set_length","text":"set_length(x, len)\n\nChange the length of x while maintaining it's first and last positions.\n\nExamples\n\njulia> using StaticRanges\n\njulia> set_length(1:10, 20)\n1:20\n\n\n\n\n\n","category":"function"},{"location":"twice_precision/#Twice-Precision-1","page":"Twice Precision","title":"Twice Precision","text":"","category":"section"},{"location":"twice_precision/#","page":"Twice Precision","title":"Twice Precision","text":"A number of operations on ranges depend on the internal type Base.TwicePrecision. This requires some uniquely handling for static ranges. This package has a limited number of methods that exist for consistency with base and easier readability when manipulating twice precision values internally. It's unlikely users should ever need to use these methods (or even know about them) but there's some minimal documentation included in case one should ever be so unfortunate to need to become aware of their existence.","category":"page"},{"location":"twice_precision/#","page":"Twice Precision","title":"Twice Precision","text":"StaticRanges.TPVal\nStaticRanges.gethi\nStaticRanges.getlo\nStaticRanges.stephi\nStaticRanges.steplo\nStaticRanges.refhi\nStaticRanges.reflo\nStaticRanges.set_ref!\nStaticRanges.set_offset!","category":"page"},{"location":"twice_precision/#StaticRanges.TPVal","page":"Twice Precision","title":"StaticRanges.TPVal","text":"TPVal{T,H,L}\n\nA static parametrized counterpart to the TwicePrecision type. Any instance of TPVal should be converted to TwicePrecision as soon as it is not serving as a parametric storage type.\n\n\n\n\n\n","category":"type"},{"location":"twice_precision/#StaticRanges.gethi","page":"Twice Precision","title":"StaticRanges.gethi","text":"gethi(x::Union{TPVal{T}, TwicePrecision{T}}) -> T\n\nReturns the hi component of a twice precision number. Works for both statically set TPVal and TwicePrecision.\n\n\n\n\n\n","category":"function"},{"location":"twice_precision/#StaticRanges.getlo","page":"Twice Precision","title":"StaticRanges.getlo","text":"getlo(x::Union{TPVal{T}, TwicePrecision{T}}) -> T\n\nReturns the lo component of a twice precision number. Works for both statically set TPVal and TwicePrecision.\n\n\n\n\n\n","category":"function"},{"location":"twice_precision/#StaticRanges.stephi","page":"Twice Precision","title":"StaticRanges.stephi","text":"stephi(x::AbstractStepRangeLen) - Returns the hi component of a twice precision step\n\n\n\n\n\n","category":"function"},{"location":"twice_precision/#StaticRanges.steplo","page":"Twice Precision","title":"StaticRanges.steplo","text":"steplo(x::AbstractStepRangeLen) - Returns the lo component of a twice precision step\n\n\n\n\n\n","category":"function"},{"location":"twice_precision/#StaticRanges.refhi","page":"Twice Precision","title":"StaticRanges.refhi","text":"refhi(x::AbstractStepRangeLen) - Returns the hi component of a twice precision ref\n\n\n\n\n\n","category":"function"},{"location":"twice_precision/#StaticRanges.reflo","page":"Twice Precision","title":"StaticRanges.reflo","text":"reflo(x::AbstractStepRangeLen) - Returns the lo component of a twice precision ref\n\n\n\n\n\n","category":"function"},{"location":"twice_precision/#StaticRanges.set_ref!","page":"Twice Precision","title":"StaticRanges.set_ref!","text":"set_ref!(x, val)\n\nSet the reference field of an instance of StepMRangeLen.\n\n\n\n\n\n","category":"function"},{"location":"twice_precision/#StaticRanges.set_offset!","page":"Twice Precision","title":"StaticRanges.set_offset!","text":"set_offset!(x, val)\n\nSet the offset field of an instance of StepMRangeLen.\n\n\n\n\n\n","category":"function"}]
}
